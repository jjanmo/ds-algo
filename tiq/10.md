# 189. Rotate Array

이런 문제가 더 싫다. 풀릴듯 말듯 안풀리는 그런 문제...

이 문제는 배열의 순서를 변경시키는 문제이다. 단, 조건이 있다. `Do not return anything, modify nums in-place instead.` 즉, mutable하게 구현하시오 라는 말로 이해된다. 그리고 여기서 `rotate`라는 말에 현혹되어서 뭔가 반복해야하는 것처럼 구현하려고 하면 답이 나오지 않는다. 그리고 또 제한조건은 이중for문 금지! 제한조건을 보면, `1 <= nums.length <= 10^5`, `0 <= k <= 10^5` 이러해서... 이중for문을 돌리면 100억번이 된다. 절대 불가... 하지만 풀이 생각나지 않아서 우선은 그냥 풀어보았다.

1.  조건에 맞지않는 풀이.

    > 감잡기위해서 풀어봄.

    ```js
    var rotate = function (nums, k) {
      for (let i = 0; i < k; i++) {
        for (let i = nums.length - 1; i > 0; i--) {
          const tmp = nums[i];
          nums[i] = nums[i - 1];
          nums[i - 1] = tmp;
        }
      }
    };
    ```

    역시나 시간초과가 뜬다. 뭔가 인덱스간의 관계를 조합해서 푸는 방법같은데..라는 생각만 어렴풋이 들었었다. 예를 들어서 `nums.length로 나머지 연산`을 통하면 하나의 배열 안에서 순회하는 인덱스를 만들 수 있을테고 이를 이용하는거 아닌가 라는 생각.

    이런 저런 생각 끝에 답이 나오지 않아서,,, 어쩔수 없이 풀이를 찾아보게 되었다. 풀이를 보고 드는 생각이 어떻게 저런 생각을 할 수 있을까. 두가지 풀이를 적을 생각인데, 첫번째 풀이는 한 번 기억해두면, 사용해보면 사용할 수도 있을법하다. 그런데 두번째 풀이는 어떤 식으로 생각하면 저런 아이디어가 떠오르는지 궁금하기도 했다.

2.  이중for문 대신 클론 배열?!

    이중for문을 사용해야했던 이유가 뭘까?!, 반복문을 사용해야했던 이유는 `in-place`하게 배열의 요소를 바꾸기 위해선 임시변수에 넣고 해당 변수끼리 교체하는 작업이 반복적으로 필요했기 때문이다. 그렇게 하지 않으면 내가 알고 싶어하는 요소의 데이터가 덮어씌어져서 사라지기 때문이기도 하다. `만약 사라지지 않는다면?!` 이 풀이가 이렇게 접근한 방법이라고 생각한다. 원배열을 클론하여 가지고 있고, 그 클론한 배열을 통해서 기존 값을 가져와서 원배열을 수정하는 방식으로 구현하였다.

    그리고 두번째는 k의 의미에 대해서 좀 더 자세히 살펴볼 필요가 있었다. 난 단지 k가 회전하는 횟수로 생각했지만, `k를 인덱스`로 바라보면 해당 배열의 k이전까지의 요소가 바뀐다는 것을 눈치챌수 있다. 또 이렇게 바라보게 되면 결국 변경전 값과 최종 변경값, 둘 사이의 연관성만 바라보면 되기 때문에 훨씬 머리가 편해질 수 있다.

    ```js
    var rotate = function (nums, k) {
      const copied = [...nums];
      for (let i = 0; i < nums.length; i++) {
        const rotatedIdx = (k + i) % nums.length;
        nums[rotatedIdx] = copied[i];
      }
    };
    ```

    `const rotatedIdx = (k + i) % nums.length`

    위 코드가 나오기까지의 과정을 잠깐 모식도로 그려보면 아래와 같다.

    ![10](/screenshots/tiq-10.jpeg)

    결국 length를 기준으로 순환한다고 보면 되기때문에 length의 나머지 연산을 배열의 인덱스에 접근할 수 있다.

3.  뒤집고 뒤집고 뒤집는다!

    이 아이디어는 어떻게 시작이되었는지 모르겠지만, 결과적으로 3번 뒤집으면 답이 나온다. k값을 기준으로 `A | B` 를 나눌수 있다.

    ```
    k = 3
          A     (k) B
    인덱스 0 1 2 | 3 4 5 6
    원배열 1 2 3 | 4 5 6 7

      1번  7 6 5 | 4 3 2 1 → 전체 뒤집기
      2번  5 6 7 | 4 3 2 1 → A 뒤집기
      3번  5 6 7 | 1 2 3 4 → B 뒤집기 = 최종

    ```

    뭔가 결과를 보고 유추하다보니 이런 아이디어가 나왔던것이 아닌가 싶다. 수에 대한 관찰력이 돋보이는 풀이라고 해야할까?!

    ```js
    var rotate = function (nums, k) {
      k %= nums.length;
      // 대칭인 수를 교환
      const reverse = (start, end) => {
        while (start < end) {
          const tmp = nums[start];
          nums[start] = nums[end];
          nums[end] = tmp;

          start++;
          end--;
        }
      };

      reverse(0, nums.length - 1);
      reverse(0, k - 1);
      reverse(k, nums.length - 1);
    };
    ```

    이 풀이는 아이디어 + 배열을 in-place로 reverse하게 만드는 것이라고 볼 수 있다.
    처음에 아래와 같이 for문으로 만들었다.

    ```js
    const reverse = (start, end, length) => {
      const middle = start + Math.floor(length / 2);

      for (let i = start; i < middle; i++) {
        const temp = nums[i];
        nums[i] = nums[end - 1 - i]; // ✅
        nums[end - 1 - i] = temp;
      }
    };
    ```

    start가 0인 경우는 예상대로 뒤집기가 잘 이루어졌지만, start가 0이 아닌 reverse, 즉 세번째 뒤집기에서 막혔다. 체크박스 부분에서 문제가 발생했는데, 위 코드는 중앙값을 기준으로 서로 대칭인 점을 바꿔주는 것인데, start가 0이 아니면서 중간값이 달라졌고, 0이 아닌 지점부터 시작하기 때문에 빼주는 값이 대칭적이지 않게 되었다. 위 문제를 해결하기 위해선 저런식의 for문이 아닌 다른 방식으로 해야했다.(사실 `ChatGPT`에 물어보았더니... 알려줌 🤪)

    ```js
    const reverse = (start, end) => {
      for (var i = start, j = end; i < j; i++, j--) {
        var temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
      }
    };
    ```

    근데 자세히 보면 결국 while문을 사용한 것과 같은 방식이다. start와 end를 대칭점 중심으로 한칸씩 이동시키면서 스왑해주는 방식인 것이다. 역시... 일반적인 for문을 사용해서는 문제를 해결할 수 없는 모양이다.(예외상황이 많이 발생...)

# 결론

오랜 시간 동안 고민도 하고 찾아보면서 해결하긴했다. 비슷한 문제를 만났을때 이러한 아이디어가 스쳐지나가길 바랄뿐 🙏🏻 빡세긴하다 🥲

이 문제를 풀다가 궁금한 점이 생겼다. 수학적인(?), 인덱스간의 관계를 맞추다가 예외 상황이 발생했다면, 그걸 어떤 식으로 해결해야할까? 이게 예외 상황인지를 인지하고, 다른 방법으로 선회해야할까? 아니면 내가 뭔가 놓친게 있다는 판단하에 계속 디깅을 해야할까? 어떤 판단을 내려야할지 잘 모르겠다. 아직 경험이 부족해서인지, 이러한 상황에서 풀이를 전환해야할지에 대한 판단을 빠르게 내릴수 없었다.

그럼에도 결국 이런 고민들을 갖은 채 풀어나갈 수 밖에 없지 않을까?! 언젠가 `감`이라는 것이 오지 않을까...
