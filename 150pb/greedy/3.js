function solution1(costs) {
  const mid = costs.length / 2;
  let totalCost = 0;

  costs.sort((a, b) => {
    const d1 = a[0] - a[1];
    const d2 = b[0] - b[1];
    return d1 - d2;
  });

  console.log(costs);

  for (let i = 0; i < costs.length; i++) {
    if (i < mid) totalCost += costs[i][0];
    else totalCost += costs[i][1];
  }

  return totalCost;
}

console.log(
  solution1([
    [10, 20],
    [30, 200],
    [400, 50],
    [30, 20],
  ])
); // 110

console.log(
  solution1([
    [259, 770],
    [448, 54],
    [926, 667],
    [184, 139],
    [840, 118],
    [577, 469],
  ])
); // 1859

console.log(
  solution1([
    [515, 563],
    [451, 713],
    [537, 709],
    [343, 819],
    [855, 779],
    [457, 60],
    [650, 359],
    [631, 42],
  ])
); // 3086

/*
self feedback

문제를 풀었는데, 왜 맞는지를 모르겠다...
도대체 왜 이렇게 풀면 맞는거지??

Q1. 왜 이렇게 풀면 맞을까?
처음 문제를 접했을 때, 정렬을 통해서 a도시 비용과 b도시 비용을 각각 정렬해서 낮은 값을 선택할 수 있을까에 대해서 고민했다.
아무리 정렬을 해봐도 제대로 된 값 구할 수 없었다.
그러다가 우연히 두 비용의 차를 기준으로 정렬했더니 제대로 된 값을 구할 수 있었다.
이 부분에 대해서 좀 찾아보면서 왜 이렇게 되는지 이해할 수 있었다.

두 비용의 차가 크다는 것은 한 쪽(a or b)을 선택하는 것이 많은 이득을 볼 수 있다는 말이다.
또 보통 비용의 차에 절대값을 씌우는데 나는 절대값을 씌우지 않고 그대로 정렬하였다.
그렇게 되면 어느 부분은 음수가 나오는데 음수가 나온다는 말은 a비용보다 b비용이 크기 때문에 거기서는 a비용을 고르면 된다.
즉 정렬된 배열에서 시작부터 n개가 되는 지점까지는 a를, 그 뒤에는 b를 선택하면 된다.
이런 식으로 비용의 차로 정렬한 배열을 토대로 앞부분은 a 선택(n개), 뒷부분은 b 선택(n개)을 하면 된다.
비용의 차를 기준으로 차가 큰 것안에서 작은 값을 선택하면 전체적으로 큰 이득을 볼 수 있게된다. ⭐️


Q2. 그렇다면 왜 이렇게 푸는 것이 그리디 알고리즘일까?
위에서 별표 친 부분이 핵심인 것 같다.
부분의 최적 해 → 비용이 차가 큰 것 중에서 작은 값(비용)
이것들을 모으면 전체적으로 최적의 해를 만들 수 있다.

이래서 그리디 알고리즘 분류에 포함되는 것이 아닐까... 자체적인 해석
*/
