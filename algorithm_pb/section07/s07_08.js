function solution1(n, data) {
  data.sort((a, b) => {
    if (a[1] > b[1]) return 1;
    else if (a[1] < b[1]) return -1;
    // if (a[1] !== b[1]) return a[1] - b[1]; // 두 조건을 합쳐서 이렇게 표현할 수 있다. 😅
    else {
      return a[0] - b[0];
    }
  });

  let endTime = 0;
  let count = 0;
  for (let i = 0; i < data.length; i++) {
    if (data[i][0] >= endTime) {
      count++;
      endTime = data[i][1];
    }
  }

  return count;
}

console.log(
  solution1(11, [
    [1, 4],
    [3, 5],
    [0, 6],
    [5, 7],
    [3, 8],
    [5, 9],
    [6, 10],
    [8, 11],
    [8, 12],
    [2, 13],
    [12, 14],
  ])
); // 4
console.log(
  solution1(5, [
    [1, 4],
    [2, 3],
    [3, 5],
    [4, 6],
    [5, 7],
  ])
); // 3
console.log(
  solution1(3, [
    [3, 3],
    [1, 3],
    [2, 3],
  ])
); // 2

/*
self feedback

해당 문제는 유명한 그리디 문제라고 한다.
왜 이문제가 그리디 문제인가?

자연스럽게 드는 생각은 어떻게 이 회의 시간 정보를 정렬하여 같은 시간 동안 가장 많은 회의를 진행할 수 있을지에 대한 경우의 수를 찾는 것이였다.
그럼 어떻게 정렬할까? 정렬 기준은??
→ 어떻게 정렬하는 것이 최적의 해인지를 생각하는 것이 그리디한 접근이다.

1. 회의 시작 시간 순서에 따라서 정렬해보았다.
2. 회의 시간(duration)을 기준으로 정렬해보았다.
3. 회의 종료 시간 순서로 정렬하였다.

이 중에서 최적의 해는 3번이다.
그런데 어떻게 이것이 최적의 방법인지 알 수 있을까?
(참고 블로그 : https://source-sc.tistory.com/59)
위 블로그의 해설을 참고하자면, 일정한 시간이 정해진 경우 하나를 선택했을때 회의 종료 시간 이후의 시간에 해당하는 나머지 회의를 선택할 수 있다.
즉, 회의를 선택하고 남은 시간이 크면 클수록 더 많은 회의를 그 안에 집어넣을 수 있는 것이다.
이를 좀 더 그리디 알고리즘에 맞게 설명하면, 종료시간에 따라 정렬된 회의를 하나 선택하면, 선택한 회의 종료 시간 이후에 해당하는 회의는 앞선 선택과 무관하게 된다. 서로 영향을 미치지않는다.

그러나... 이러한 생각을 하면서 이 정렬 기준을 선택할 수 없을 것이다.
내 개인적인 생각으로 이 문제를 직접 코테에서 푸는 시간이라면, 정렬 기준을 여러가지로 세운뒤 반례를 찾아가면서 해당 기준이 맞는지를 확인하고
맞다면 그 기준에 맞게 구현하면 답을 찾는 것이 맞다고 생각한다.
위와 같은 알고리즘적인 생각은 들면 좋은 것이고 그 순간에 들지 않아도 되는 것들 아닐까 생각한다.

⭐️ 그리디 알고리즘의 선택
내가 어떠한 선택을 했을때, 그 선택이 나중에 선택할 것에 영향을 미치면 안된다.
그 선택만으로 독립적이야한다.

https://susufana.tistory.com/97 : 그리디 알고리즘 문제에 대한 접근에 도움을 주는 블로그

*/
