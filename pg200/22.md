# 점프와 순간 이동

> 고민 끝에 낙이 온다

## 생각의 흐름

처음 문제를 접했을때, 감이 올듯 안 올듯 애매했다. 몇가지 단서를 찾기시작했다.

- 점프를 최대한 많이 사용하면 될 것 같은데, 이것을 어떻게 설정하는거지??

- 점프는 언제 해야하는 거지??

어쨌든 점프, 즉 2배를 한다는 것이 포인트이기때문에, 이를 이용하는 방법으로, 2의 배수, 2진수, 2^n으로 만들어야할까 등등의 방법으로 여러가지로 손계산을 시도해보았다. 그러다가 `수학적인 식`을 얻을수 있을까 해서, 주어진 예시를 천천히 식으로 나타내 보았다.

```
INPUT : 6

(1 * 2 + 1) * 2 = 6

→ 역산 : ((6 / 2) / 2 - 1) / 2 - 1 = 0

INPUT : 5

(1 * 2) * 2 + 1 = 5

→ 역산 : ((5 - 1) / 2) / 2 - 1 = 0
```

> 역산 부분을 살펴보면 `2로 나누었을때 나머지가 1인 경우를 더하면 그게 이동거리(배터리 사용량)가 된다`는 것을 알게 되었다. 그래서 나누기(/)와 나머지(%)를 통해서 이를 표현해볼 수 있다는 생각이 들었다.

```js
function solution(n) {
  let d = 0;
  while (n > 0) {
    const q = Math.floor(n / 2); // 몫
    const r = n % 2; // 나머지
    d += r;
    n = q;
  }

  return d;
}
```

> 위 코드를 코드 양적으로 좀 더 줄일 수 있다. 변수에 할당하지 않고 바로 연산에 q, r을 활용할 수 있으나, 나는 변수에 할당해서 사용하는 것이 좀 더 명확하고 보기 편하다고 생각하는 편이라서 기본적으로 이런 스타일로 작성한다.

## 다른 풀이

위 문제가 2진수에 대한 것일까 생각한 적이 있었지만, 그쪽으로는 접근하지 못했다. 그런데 실제로 다른 사람들의 풀이를 보니 그렇게 접근한 코드가 있어서 첨부해본다.

이진수란 어떻게 만들어질까? 특정 N을 2로 나누면서 나머지가 0이나 1로 나온 값을 하나의 수로 표현한다. 즉 2로 나눈 나머지들의 콜렉션이다. 위에서 말하길, `2로 나누었을때 나머지가 1일때를 다 더하면 그것이 점프가 아닌 실제 이동거리(배터리 사용량)가 된다` 라고 했다. 그렇기 때문에 2진수로 변환 후에 1인 값만 모두 더하면 그게 결국 이동거리(배터리 사용량)가 된다. 아래는 위 로직을 구현한 코드이다.

```js
function solution(n) {
  if (n === 1) return 1;
  const nArr = Array.from(n.toString(2));
  return nArr.reduce((a, b) => +a + +b);
}
```

> toString(N)는 이전에서도 공부했던 것처럼 특정수를 N진법으로 변환하는 메소드이다.

## 결론

사실 어떻게 풀었는지 잘 설명해봐 라고 한다면, 위에서 말한 정도밖에 말을 못하겠다. 뭔가 감각적으로(?) 이것 저것 손으로 직접 계산식을 만든다던지 도식화 비슷한 플로우를 그려본다던지를 통해서 문제를 풀 수 있었던 것 같다. 사실 구현한 코드만을 보면 진짜 소소한 코드지만 이를 문제를 보고 생각해내는데까지는 상대적으로 오랜시간이 걸린다는 것! 이래서 프로그래머, 개발자라는 사람들은 사실 코딩하는 시간보다 기존 코드를 읽거나, 문제 상황을 분석하거나 하는데 시간을 더 들여야함을 다시금 느낀다. 🙏🏻
