# 네트워크

> 풀긴했는데... 음음

처음에 위 문제를 단순하게 생각했다. 꼭 모습과 예시를 통한 결과를 보니 그래프 문제로 유명한 `섬의 개수` 문제와 유사했다. 그래서 그냥 아무 생각없이 우선은 섬의 개수를 구하는 방법으로 구현을 해보았다. 예제 TC는 통과하였지만 역시나 문제는 틀렸다. 왜 틀리지, 어떤 반례가 있나 라는 생각을 해보았다. 이 문제에 직접적인 도움이 되지않더라도 몇가지 `지식적인 내용`을 찾을 수 있었다. 알면 좋으니 정리해보자.

---

- 그래프(DFS/BFS) 문제의 대표적인 유형

  1. 경로 탐색 유형
     - A-B까지 가는데 걸리는 최단 거리/시간
  2. 네트워크 유형 → `위 문제에 해당`
     - 연결 되어 있는 그룹의 개수 혹은 개체 간의 연결 여부 확인
  3. 조합 유형
     - 여러가지 조합을 만들어서 비교해보는 문제

- 그래프(DFS/BFS)의 구현방법

  - DFS : 재귀나 스택이용

    - 나는 주로 재귀를 이용하긴한다. 스택을 이용하는 방법으로도 풀어봐야 상황에 따라서 적절한 방법을 선택할 수 있을거라 생각한다.(연습해야지...🔥)

  - BFS : 큐 이용

- 그래프의 종류

  - 무방향(양방향) 그래프 : 양쪽 모두 연결 가능

  - 단방향 그래프 : 간선이 방향을 지님

- 그래프를 코드로 표현하는 방법(`그래프의 연결상태`를 보여줌)

  - 인접행렬 : 한 정점에서 다른 정점으로 연결되어있다면 1, 없다면 0으로 표현, 무방향 그래프의 경우 인접행렬이 대각선을 기준으로 `대칭`을 이룬다

  - 인접리스트 : 한 정점에서 연결된 다른 정점들을 그룹핑하여 표현한 것

    ```
          0 1 2 (여기 인덱스는 관계없음)
        -------------------
      0 | 0 1 → 0번 노드와 연결된 노드는 0과 1이라는 의미
      1 | 0 1 → 1번 노드와 연결된 노드는 0과 1이라는 의미
      2 | 2 → 2번 노드와 연결된 노드는 2라는 의미 (연결된 노드가 없다!)
    ```

    > 인접리스트 예시

> [참고링크](https://sophia2730.tistory.com/entry/Data-Structure-Graph-%EA%B7%B8%EB%9E%98%ED%94%84) / [참고영상](https://www.youtube.com/watch?v=BsYbdUnKZ-Y&t=79s)

---

문제로 다시 돌아오면, 내가 이 문제를 섬의 개수 문제처럼 푼 이유는 주어진 인접행렬에서 연결관계가 섬의 개수와 맞아떨어졌기 때문이다. 나의 큰 착각! (혹시 같은 문제인가라는 요행을 바라고...) 생각해보면 당연하다. 섬 문제에서 주어진 행렬은 인접이 행렬이 아니라 그냥 단순히 섬의 위치를 보여준 것이고(그저 지도를 행렬로 표현한 것), 이것은 컴퓨터간의 연결상태를 인접행렬로 표현한 것이다.

문제를 풀기위해 어떻게 하면 연결여부를 알 수 있을까에 대한 고민을 하였다. 좀 더 자세히 말하면 인접행렬 혹은 인접리스트를 통해서 시각적으로 보는 노드간의 관계를 어떻게 알 수 있을지가 궁금했다.

우선은 주어진 인접행렬로는 판단할 수 없을거 같아서 인접리스트를 구하였다. 인접리스트를 통해서 봤을 때, 만약에 네트워크가 1개라면(모든 컴퓨터가 연결되어 있다면) dfs를 통해서 들어가서 탐색을 하면 모든 컴퓨터를 방문(체크)할 수 있다. 즉 내가 컴퓨터를 체크(방문)할 때 마다 해당 컴퓨터를 기록하여 체크가 끝날 때를 기준으로 네트워크 개수를 카운팅할 수 있겠다 라는 설계가 세워졌다.

아래는 위를 토대로 구현한 코드이다.

```js
function solution(n, computers) {
  let count = 0;
  const visited = [];
  const graph = Array.from({ length: n }, () => []);
  for (let i = 0; i < computers.length; i++) {
    for (let j = 0; j < computers[0].length; j++) {
      if (computers[i][j] === 1) {
        graph[i].push(j);
      }
    }
  }

  const dfs = (x) => {
    for (let i = 0; i < graph[x].length; i++) {
      if (!visited.includes(graph[x][i])) {
        visited.push(graph[x][i]);
        dfs(graph[x][i]);
      }
    }
  };

  for (let i = 0; i < graph.length; i++) {
    if (!visited.includes(i)) {
      count++;
      dfs(i);
      visited.push(i);
    }
  }

  return count;
}
```

# 결론

이번 문제는 사실 버벅이긴했지만, 특별한 코드적인 도움(의사코드나 다른 언어로 된 풀이)없이 나의 생각을 풀어냈다는데 의미가 있다고 생각한다. 사실 섬 문제처럼 풀 때도 틀릴 줄 알고 푼거긴했지만, 그러고 나서 살짝 막막했다. 내가 눈으로 본 이것(네트워크가 연결된 도식)을 코드로 어떻게 표현하지 라는 막막함. 그래프 문제는 예전부터 그런 부분이 어렵다고 느낀 것 같다. `도식화(시각화)되어있는 그래프를 어떻게 코드로 이해시킬 것인가`에 대한 문제! 프런트엔드에서는 이런 그래프적인 부분을 구현할 일이 그렇게 많지는 않지만, 게임 개발이나 네트워크의 로직적인 부분을 담당하는 개발자들은 눈으로 보는 것을 코드로 상상하는 일이 많이 필요하지 않을까 하는 생각을 해본다. 나도 게임 개발은 해보고 싶은데...그러려면 이런 구현에 익숙해져야하나...😅
