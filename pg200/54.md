# 분수의 덧셈

> 유클리드 호제법 정리

이 문제는 예전에는 못풀었었다.(그 때는 파이썬으로 풀었었는데, 뭔가 조건문의 나열로 풀려다가 못풀었었다.) 이번에 다시 문제를 읽으면서 아이디어가 떠올랐고 그 아이디어 가운데 유클리드 호제법이 있었다. 유클리드 호제법은 두 수 사이에 최대공약수를 구하는 알고리즘이다. 수학적으로 여러가지 의미가 있겠으나, 나는 단순히 이것을 어떻게 이용하고 어떻게 구현할지에 대해서 정리해보고자 한다.

우선, 이 문제의 아이디어는 2개의 분수를 그냥 더한다. 더하기 위해선 분모를 같게 맞춰야하기 때문에 두 분모를 곱한 후 분자에 각각의 값을 곱해서 맞추고 두 분수를 더해준다. 이제 더해진 분수의 분자와 분모가 기약분수인지 여부를 확인해야한다. 이 때 유클리드 호제법을 구현해야한다. 분자와 분모의 최대공약수를 구해서 양쪽을 나눠주면 끝이다.

사실 이전에도 유클리드 호제법에 대해서 구현해봤었는데, 다시 한번 찾아보면서 그 과정을 한번 정리해볼 필요가 있어보였다.

```
두 수 a, b 존재
a % b = r
1. r === 0 : b가 최대공약수
2. r !== 0 :
    a = b
    b = r
    a % b를 확인
3. r이 0이 될 때까지 2번을 반복하면 값을 확인
```

> 과정을 설명하면 위와 같다.

위의 과정에 따라서 실제 예시를 통해서 과정을 나열해보겠다.

1. 일반적인 예 : `a = 24, b = 8`

2. 기약분수(?) 관계 : `a = 19, b =7`

3. 거꾸로 되었다면? : `a = 8, b = 24`
   > 처음에는 Math.max() 등을 통해서 a,b의 순서를 정해서 나누어주어야할까에 대한 고민을 했었다. 하지만 아래에서 보다싶이 결국 반복의 과정을 거치면 순서대로 바뀌게 된다.

![유클리드 호제법](/screenshots/pg200-54.jpeg)

이미지에서 적은 것처럼 2가지 방법이 있을 수 있다.

- 계속 반복하면서 두 수의 나머지가 0인 경우를 체크하는 방법

- b가 0이 될 때까지 그냥 계속 반복하는 방법

처음에는 전자의 방법으로 구했었다. 다른 코드를 참조하던 중에 후자의 방법으로 코드를 구현한 것을 보게되었다. 어차피 같은 방법이고 결과적으로 같다면, 조건이 적게 들어가는 로직이 이해하는게 더 편하다는 생각이 들었다. 이게 별거 아닌것 같지만 생각의 흐름에서 큰 차이를 보이는 것 같다. 나의 경우는 그랬다.

아래 코드에서 while문 부분이 최대공약수를 구하는 코드이다.

```js
function solution(numer1, denom1, numer2, denom2) {
  const t = numer1 * denom2 + numer2 * denom1;
  const d = denom1 * denom2;

  let a = t,
    b = d;
  while (b !== 0) {
    const tmp = a % b;
    a = b;
    b = tmp;
  }
  // while문이 끝나면 a가 최대공약수가 되어있음

  if (t % a === 0) return [t / a, d / a];
  return [t, d];
}
```
