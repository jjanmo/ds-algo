# 모음 사전

> 중복순열, DFS 드디어 풀어봄! 그러나...

완전탐색 문제이고 이제 문제를 보면 `아하 이건 DFS를 이용해야하는군` 정도까지의 감은 잡을수 있었다. 거기에 이 문제는 중복순열과 같은 문제! (사실 예전에 중복순열을 구현해봤는데...잘 기억이 안나서 이번에 다시 복습하게 되었다.🤪) 보통 순열 혹은 중복순열은 n개 중에 m개를 뽑는다는 조건이 있다. 하지만 이 문제는 모음 사전으로서 문자열 1 ~ 5까지의 모든 모음으로된 중복순열을 구해야했다. 그래서 길이마다 함수 dfs를 반복시켜주는 방식으로 풀어나갔다.

## Try1

```js
function solution(word) {
  const vowel = ['A', 'E', 'I', 'O', 'U'];
  const tmp = [];
  const result = [];

  const dfs = (l) => {
    if (l === tmp.length) {
      result.push(tmp.join(''));
    } else {
      for (let i = 0; i < vowel.length; i++) {
        tmp.push(vowel[i]);
        dfs(l);
        tmp.pop();
      }
    }
  };

  // ✅ 꼭 이렇게 for문을 한 번 더 돌아야할까?
  for (let i = 1; i < 6; i++) {
    dfs(i);
  }

  return result.sort().indexOf(word) + 1;
}
```

이 풀이에서 가다듬고 싶은 부분은 바로 체크박스 부분. 이 부분이 꼭 필요한 것일까? 없앨 수 있을거 같은데... 또한 나는 문자열이 1개인 경우 구하고 2개인 경우 구하고 ...를 반복하기 때문에 모든 경우의 수를 구한 뒤에 다시 sort() 함수를 할 수밖에 없는 상태였다.(사전순 정렬이 안됨!!) 처음부터 알아서 모든 경우의 수를 구할 수 있는 방법은 없을까? 즉, 사전순으로 문자열을 구해서 result에 넣는 방식!!

```js
// 1)
function solution1(word) {
  const vowel = ['A', 'E', 'I', 'O', 'U'];
  const tmp = [];
  const result = [];

  const dfs = () => {
    if (tmp.length > 5) return;

    result.push(tmp.join(''));

    for (let i = 0; i < vowel.length; i++) {
      tmp.push(vowel[i]);
      dfs();
      tmp.pop();
    }
  };

  dfs();

  return result.indexOf(word);
}

// 2)
function solution(word) {
  const vowel = ['A', 'E', 'I', 'O', 'U'];
  const result = [];

  const dfs = (p) => {
    if (p.length > 5) return;

    result.push(p);

    for (let i = 0; i < vowel.length; i++) {
      dfs(p + vowel[i]);
    }
  };

  dfs('');

  return result.indexOf(word);
}
```

for문 없이 한번이 푸는 방식으로 수정해보았다. 무엇이 어떻게 다른지 살펴보자. 1번 풀이가 내가 구현한 코드와 유사하다. 다른점은 `end조건`이다. 기존에는 l이라는 인자를 통해서 재귀함수의 end조건을 주었지만, 사실 문자열 길이를 통해서도 같은 조건을 줄 수 있다. 그리고 문제에서는 문자열의 길이가 1 ~ 5개까지 모두 가능한 경우의 수이다. 그래서 각각 순서대로 깊이 탐색을 통해서(문자별로 문자열이 길어지는 순서) 만들어지는대로 배열에 넣어주면 이제 알파벳 순서대로 문자열이 만들어지는 것이다.

그럼 2번째 풀이는 무엇이 다른가?? 바로 문자열의 변수의 위치가 다르다. 1번 풀이는 `tmp라는 전역변수`를 통해서 만들어지는 문자열을 관리하였다. 그래서 어쩔수 없이 tmp.pop()과 같은 작업이 필요했다. 왜냐하면 한번 깊이 탐색으로 통해서 순회하고 나서 다음번 순회로 넘어갈때는 현재 tmp가 아니라 이전 tmp에서 진행을 해야하기 때문이다. 그래프로 보면 레벨을 한단계 거슬러가야하는 것을 표현한 코드라고 볼 수 있다.(사실 DFS에서 이 부분이 가장 이해가 안되었던 부분!, 표현과 구현이 일치하지 않는다랄까?!) 반면 2번 풀이에선 각 단계에서의 문자열을 인자로 넣어준다. 즉 `각 함수마다 지역변수`로서 존재하게 된다. 그래서 문자열을 빼주고 하는 작업이 필요없게 되는 것이다.

## 그러나...

나는 당연히 위 문제를 다들 dfs를 이용하여 완전탐색을 하여 풀었을것이라고 예상했다. 하지만 좋아요가 가장 많이 찍힌 문제들 혹은 상위에 노출된 문제들은 다 요지경 속에서 기발하게 푼 풀이였다.

사실 이 문제는 완전 탐색보다는 `규칙을 찾는 문제`라고 접근하는 사람들이 많았던 것 같다. 개인적으로 어떻게 이 문제에서 규칙이 있을 것이라고 예상을 하고 규칙을 찾으려고 나열을 해보는 작업을 하게 되었는지 의문이긴하다. 문제 풀기 전에 문제를 풀기 위한 사전 작업들이 더 중요하다고 본다. 이것도 그와 같은 맥락에서 직접 나열해보고 아하 규칙이 있군 하고 찾아가는 과정! 이걸 하기까지가 어려운 것 같다. 무튼 아래 풀이들은 문자열이 어떻게 변하는지에 대한 규칙성을 찾아서 그것을 이용한 풀이이다. 그렇다면 어떤 규칙성일까?!

![규칙성](/screenshots/pg200-48.jpeg)

---

아래 코드에서 위 모식도(?)의 오른편에 적혀있는 규칙성으로 토대로, 각 자리수에서 알파벳이 변함에 따른 증가율을 배열로 하여 이용하고 있다.

```js
function solution(words) {
  return words
    .split('')
    .reduce(
      (r, c, i) =>
        r + [781, 156, 31, 6, 1][i] * ['A', 'E', 'I', 'O', 'U'].indexOf(c) + 1,
      0
    );
}
```

이제 코드가 이해되니, 뭔가 기가막힌 코드였다는 생각이 든다. 자리수에 따라서 몇 번 변화하였는지를 누적합을 구하면, 딱 그에 해당하는 단어가 몇번째 순서의 단어인지 나온다! 캬캬캬 👍🏻

---

```js
const VOWELS = ['A', 'E', 'I', 'O', 'U', ''];

const f = (a) => VOWELS.map((b) => b + a);

function solution(word) {
  return Array.from(
    new Set(VOWELS.map(f).flat().map(f).flat().map(f).flat().map(f).flat())
  )
    .sort()
    .indexOf(word);
}
```

이 문제의 핵심은 VOWELS 배열 안에 `빈문자열`에 있다고 생각한다. `빈문자열`을 통해서 map()을 다섯번 돌렸지만, 문자열의 길이가 1 ~ 5까지 나오게 할 수 있었다. 성능을 떠나서 개인적으론 이 풀이가 로직을 이해하기쉽고 코드도 가독성이 좋다고 생각한다.
