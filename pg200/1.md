# 3진법 뒤집기

> 문제 풀이 보다는 여기서 새롭게 배운 `내장함수`에 대해 기록한다. (사실 새로운 것이 아님!)

> `toString()` 과 `parseInt()` 의 활용법

# 정리

```js
function solution(n) {
  const result = [];
  let total = 0;
  while (n > 0) {
    result.unshift(n % 3);
    n = Math.floor(n / 3);
  }

  result.forEach((num, index) => {
    total += num * Math.pow(3, index);
  });

  return total;
}
```

> 1️⃣ 첫번째 풀이 : 나의 풀이

> 전형적으로 문제의 설명에 맞춰서 풀이함. 단, `3진법수를 뒤집는다`에 포인트를 맞춰서 `unshift` 통해서 한번 만들어진 배열을 그대로 사용할 수 있도록 하였다.

## 첫번째, 그런데 말입니다...

3진법을 나처럼 나눠서 직접 구하는 방법 외에도 자바스크립트에서 제공해주는 내장함수가 있었으니... 바로 `toString()` 이다.

일반적으로 toString()은 문자열을 반환하는,즉 `특정 값을 문자열로 변환`하기 위해서 사용하는 가장 기본적인 내장함수이다. 그런데 해당 함수에 매개변수가 들어가면 매개변수에 맞는 진법으로 변환시켜준다. 반환값은 n진법으로 변환된 문자열이 된다. ([MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98))

```js
let num = 255;
let base = 6;
console.log(num.toString(base)); // '1103'
```

> Syntax는 위와 같다. `10진법인 num를 6진법수로 변환한 값을 주세요` 라는 의미가 된다.

> base(기수, 'base 진법'으로 표현)로 사용될 수 있는 범위는 2 ~ 36 까지이고 이를 넘어가면 에러가 발생한다.

이를 이용하면 아래처럼 좀 더 쉽게 풀 수 있다.

```js
function solution(n) {
  return [...n.toString(3)].reduce(
    (acc, cur, i) => acc + cur * Math.pow(3, i),
    0
  );
}
```

> 2️⃣ 두번째 풀이

> `n.toString(3)`을 통해서 n으로 전달받은 수를 3진법수로 변환한 문자열을 반환하게 된다. 이것을 다시 전개연산자(...)로 펼쳐서 배열로 만들어 준다. 그리고 reduce를 통해서 배열의 요소들과 연산을 진행한다.

> 여기서 문자열을 전개연산자로 펼쳤기 때문에 분명 각각의 요소들이 문자열일텐데 어떻게 곱셈 연산이 진행되었을까? 자바스크립트에서는 `*연산`(나누기 연산도 마찬가지)을 실행할 때, 피연산자를 숫자형으로 `강제형변환`을 진행한다. 이 때, 피연산자가 숫자형인 경우, 문제없이 연산이 진행된다. 여기서도 이러한 내부적인 과정을 거쳐서 연산이 진행된 것이다.

## 두번째, 그런데 말입니다...

위 코드를 좀 더 단순하게 만들수 있었다. 바로 `parseInt()`라는 내장 함수를 사용해서 말이다.

```js
parseInt('100px'); // 100
parseInt('Hello 1004'); // NaN
parseInt('1000원'); // 1000
parseInt('12.3'); // 12
```

기본적으로 parseInt는 `문자열을 숫자로 변환`시켜줄 때 사용한다. 단, 인자로 들어오는 값이 `숫자로 시작하는 경우에만` 제대로된 숫자 값을 반환한다. 즉, parseInt는 인자로 들어온 값에서 숫자를 읽는 도중 숫자가 아닌 값이 나오면 이전까지 읽었던 숫자값만을 반환하는 것이다.

> 실무에선 CSS 등에서 '100px', '8rem'와 같이 숫자와 단위를 함께 쓰는 경우가 많은데, 이 때 parseInt를 이용하면 숫자만을 추출하여 사용할 수 있다. (나같은 경우, 이런 식으로 사용하지는 않아서... 😅)

하지만 여기서 위 문제에서 사용하려는 방법은 다른 방법이다. n진법의 수를 10진법수로 변환하는 방법.

```js
parseInt(str, radix); // str : 문자열 / radix : 숫자

parseInt('0xff', 16); // 255
parseInt('0021', 3); // 7
```

> 위에 syntax처럼 두번째 인자를 선택적으로 넣어줄 수 있다. 두번째 인자는 첫번째 인자로 들어온 값에 대한 n진법임을 알려주고 그 수를 파싱하여 준다.

> `radix가 2보다 작거나 36보다 큰 경우` 나 `공백이 아닌 첫 문자를 숫자로 변환할 수 없는 경우`에는 NaN을 반환한다.

이를 이용하면 아래처럼 좀 더 쉽게 풀 수 있다.

```js
function solution(n) {
  return parseInt([...n.toString(3)].reverse().join(''), 3);
}
```

> 3️⃣ 세번째 풀이

# 결론

기존의 내장함수에 대해서 좀 더 깊이 있고 다양한 활용성에 대해서 알 수 있는 시간이 되었다. 만약에 내가 이 둘 함수의 활용에 대해서 알았다면 어떻게 풀었을까? 그래도 나는 첫 번째나 두 번째 방법으로 풀었을 것 같다. (세 번째 방법까지는 가지 않았을 것 같다.) 왜냐하면 코드 안에 내장함수 자체가 뭔가 선언적이지 못한 부분이 있어서, 코드를 보고 이게 어떤 동작을 하는 것인지에 대해서 알기 어렵다고 느껴지기 때문이다. (즉 가독성이 떨어진다!) 물론 해당 함수에 대한 여러 활용법에 대해서 알고 있으면, 이해할 수 있겠지만 말이다. 항상 나는 많은 사람이 보편적으로 이해하기 쉬운 코드를 작성하고자 노력하기에, 나의 기준에선 어려운 코드인 것 같다. 하지만 이러한 함수들의 새로운 활용법들은 항상 알아두면 어디선가 쓸모 있을 것이다. 👍🏻
