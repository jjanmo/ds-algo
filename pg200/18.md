# 숫자의 표현

> 오답에서 정답까지!

## Try1

우선, 이중for문으로 돌리면 되겠군 후후 라는 생각과 함께 구현을 시작하였다. 거기에 추가로 제한조건도 확인! 최대 n = 10000 으로 O(n^2)이면 100000000(1억)의 연산횟수가 나온다. 예전에 1초에 연산가능한 시간복잡도에 대해서 찾아봤을때, 코테에서는 10억 정도라고 들었기 때문에 충분히 가능하겠군 이라는 확신이 들었다.

또한 n까지 순회를 해야할 필요가 없다는 생각도 들었다. 반절까지만 순회를 하면 더이상 순회를 할 필요가 없다. 왜냐하면 중간값 부근의 몇 개의 수를 더해서 n이 나왔는데, 그보다 큰 수를 더하는 경우에는 당연히 n보다 큰 수가 나올 것이 당연하기 때문이다.

```js
let count = 1;
for (let i = 1; i <= Math.ceil(n / 2); i++) {
  let total = 0;
  for (let j = i; j <= Math.ceil(n / 2); j++) {
    total += j;
    if (total === n) {
      count++;
      break;
    }
  }
}

return count;
```

오잉?? 당연히 정확성 테스트는 모두 통과하였는데... 효율성테스트 모두 탈락!! 😨

음... 시간초과인 것으로 보니 O(n^2)으로 풀면 안된다는 말인데... 내가 알고 있던 정보가 잘못되었던 부분인 것인가?! 여러가지 정보를 확인해보니... n이 1억 개일때, O(n)이 1초 정도 걸린다고 생각하면 되고 일반적으로 코테에서는 이정도 수치면 타임아웃 에러가 뜬다고 한다. (예전에 10억의 연산은 가능하다는 이야기는 잘못된 정보로...) 즉, 위 조건으로 보면 O(n^2)은 1억이니 이정도 연산수치면 효율성 테스트를 떨어지고도 남는 수치인듯...

## Try2

시간초과를 줄이기 위한 방법을 생각해보았다.

- 이중for문을 돌리지 않는 방법은 없을까?

  `투포인터 알고리즘`과 유사한 방법으로 접근했다. 아래 코드가 바로 구현체(?)이다.

```js
function solution(n) {
  let left = 0,
    total = 0,
    count = 0;

  for (let i = 1; i <= n; i++) {
    total += i;
    if (total === n) count++;
    else if (total > n) {
      while (true) {
        left++;
        total -= left;
        if (total === n) count++;
        else if (total < n) break;
      }
    }
  }

  return count;
}
```

## 시간 효율성 테스트 관련 참고

프로그래머스에서 시간효율에 대한 테스트가 약간 들쭉날쭉이다. = 을 넣어다 빼거나, 로직적인 변경이 아닌 약간의 코드 수정만으로 시간효율 테스트가 통과되었다 안되었다 하는 경우를경험했다. 또 문제 질문에서도 `var → let`로 변경하니 된다는 둥 그런 이야기도 있었다. 🤔
