# 행렬의 곱셈

> 포인트만 정리

행렬의 곱셈에서 포인트는 아래 두가지라고 생각한다.

- 두 개의 행렬이 어떠한 경우에 곱셈이 가능한지 (문제의 조건에서는 항상 곱셈이 가능한 행렬 2개가 주어진다고 함!)
- 곱셈 후 어떤 행렬이 나올지

```
A x B  *  B x C
```

- 곱셈이 가능한 행렬은 위 행렬 적은 것에서 보이다싶다 `B`가 같은 두 행렬이 계산이 가능하다. 즉, 나중에 배열을 순회할 때, 어떤 배열의 인덱스를 공유할지를 체크할 수 있다.

- 두 배열의 결과값으로 `A x C` 의 배열이 탄생한다. 즉, 구현할때 어떤 배열을 곱해서 나온 값을 결과값에 push 해야할지는 결정할 때 도움이 된다.

```js
function solution(arr1, arr2) {
  const result = [];
  for (let i = 0; i < arr1.length; i++) {
    const sub = [];
    for (let j = 0; j < arr2[0].length; j++) {
      let total = 0;
      for (let k = 0; k < arr1[0].length; k++) {
        total += arr1[i][k] * arr2[k][j];
      }
      sub.push(total);
    }
    result.push(sub);
  }

  return result;
}
```

# 결론

솔직히 위 문제를 풀 때, 약간의 노가다를 많이 했다. 위에서 말한 포인트만으로 머릿 속에서 잘 정리가 안되었고, 그래서 손으로 직접 적어가면서 인덱스간의 규칙을 찾기 위해서 적고 적고를 반복했다. 또한 이런 저런 예시들을 돌려보고, 인덱스를 수정해보고 콘솔을 찍어보는 과정을 반복하면서 코드를 구현한 것 같다. 그래서 뭔가 내가 이 원리를 정확히 알고 구현했다라기보다 노가다를 통해서 구현한 느낌이라서 꺼림직한 부분이 있다.

이렇게 행렬의 곱셈을 넘어서, 좀 더 일반적으로 이차 / 삼차 배열을 잘 다룰줄 아는 것이 실무에서도 간혹 나오는 데이터들을 다룰 때 도움이 되는 부분이 있다.(나의 경험으로는 시간표(5 x 12 배열) 관련해서 데이터를 만들고 UI를 뿌려주고 하는 부분이 있었다.) 또 그래프 자료구조를 할때도 이차 배열을 이용하기 때문에, 단순히 곱셈을 풀었다라기보다 이차 배열에 익숙해지는 유익한 시간이 된 것 같다.
