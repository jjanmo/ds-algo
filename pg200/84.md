# 방문 길이

> 같은 길이란?!

전체적인 로직은 어렵지 않게 작성하였다. 그런데 내가 한가지 빼먹은 부분이 있었다. 그것은 `같은 길`에 대한 정의를 잘못했다는 것이다. 몇 번의 시행착오를 통해서 같은 길에 대한 정의를 바르게 할 수 있었다. 같은 길의 정의가 중요한 이유는 이 문제에서는 `처음 걸어본 길`에 대해서만 체크를 하기 때문에 좌표가 이동할때 이 길이 지나간 길인지 여부를 확인할 필요가 있었다. 그래서 나는 `Set`을 이용해서 이를 체크하고자 하였다.

처음엔 해당 좌표만을 문자열로 `${x}-${y}` 이런 식으로 변환하여 Set에 담았다. 그런데 이 방법은 `길`이 아니라 점이기 때문에 다른길을 통해서 같은 좌표로 돌아오는 경우 문제가 생겼다. 그래서 두번째는 `시작점(x,y)-끝점(x,y)` 이런 형태로 변환하면 Set에 담았다. 이 경우는 테스트 케이스 30%를 통과하였다. 이 때부터 고민이 시작되었다. 어떤 예외 케이스가 있었던 것인지에 대한 고민. 그런데 이것은 예외케이스라기보다 위에서 언급한 것처럼 같은 길에 대한 정의를 좀 더 명확하게 했어야했다.

나는 시작점과 끝점을 좀 더 구체적으로 적었다. 그런데 이 반대로 길을 지났다면 그 길은 같은 길인가? 맞다. 그 길은 같은 길인 것이다. 즉, 하나의 이동 경로를 Set에 담을 때, `시작점(x,y)-끝점(x,y)`뿐만 아니라 `끝점(x,y)-시작점(x,y)` 도 담아야했다. 아래 체크박스로 표시된 코드가 바로 그 코드이다.

어렵지는 않았지만 함정이 있는 그런 문제였다.

```js
function solution(dirs) {
  const paths = new Set();
  const current = [0, 0];
  const coord = {
    U: [0, 1],
    D: [0, -1],
    R: [1, 0],
    L: [-1, 0],
  };

  const result = [...dirs].reduce((acc, dir) => {
    const [cX, cY] = [...current];
    const [dX, dY] = coord[dir];

    if (dX + cX > 5 || dX + cX < -5 || dY + cY > 5 || dY + cY < -5) return acc;

    current[0] = dX + cX;
    current[1] = dY + cY;
    const path = `${cX}${cY}_${current[0]}${current[1]}`;
    const reverse = `${current[0]}${current[1]}_${cX}${cY}`; // ✅ 추가한 부분

    if (!paths.has(path)) {
      paths.add(path).add(reverse); // ✅ 변경된 부분
      return acc + 1;
    }
    return acc;
  }, 0);

  return result;
}
```
