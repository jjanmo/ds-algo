# Two Sum

> 문제) Given an array of numbers, return all pairs that add up to a given sum. The numbers can be used more than once.

> 배열과 합의 결과가 주어진다. 주어진 결과를 만들 수 있는 한 쌍의 숫자를 배열 안에서 골라서 리턴하시오.결과가 1개이상인 경우 모두 리턴하시오

# WIL(What I Learned this problem)

> 이 문제를 통해서 알게 된 사실들에 대해 간단하게 정리한다.

## Solution 1

> 일반적인 방법인 `이중for문`을 사용하여 해결하였다. 여기에서 주어진 예시의 경우에는 아무런 문제없이 해결이 된다. 하지만 역시 O( n <sup>2</sup>) 이기 때문에 배열의 수가 많아진다면 시간초과가 나올 확률이 높다.

> > 시간초과에 대한 기준 : 보수적으로 잡아서 1초에 1억번이상의 연산을 진행하면 그 알고리즘은 시간초과라고 할 수 있다고 한다.

## Solution 2

> `couterpart` 짝을 이용하는 방법이다. 배열을 돌면서 역으로 전체합에서 각 요소를 빼서 그 결과값이 배열에 존재하는지를 확인하는 것이다. 그렇게 하면 for문 한 번이면 문제가 해결된다.

```
solution1 start: 15.137ms
solution2 start: 1.845ms
```

> 솔루션1과 2의 실행시간(performance)비교이다. 주어진 배열에 대한 연산횟수가 많지 않았음에도 두 솔루션의 차이는 15배정도 났다.

### 궁금증

> 난 사실 indexOf 역시 내부적으로 for문을 돌기 때문에 결국 이중for문과 같은거 아닐까하는 생각을 하였다. 찾아본 결과 이중for문과 indexOf가 있는 for문에 대한 비교는 없었다. 추론해보면, 우선 결과적으로 이중for문보다는 확실히 빠르다는 것이 나왔기 때문에 내부적으로 단순 for문이 아닌 다른 알고리즘에 의해서 작동된다고 생각해야만 할 것 같다. 또한 한가지 더 예상을 해보면 이중for문의 경우 n(입력값)이 늘어나면 n에 제곱 배로 연산횟수가 늘어나지만, indexOf 같은 경우, n이 늘어남과 관계없이(내부적으로 for문을 돌지라도) 항상 일정한 연산속도를 갖추기 때문에 그런 것이 아닌가하는 예상을 해본다. 정확한 이유에 대해서는 좀 더 공부가 필요할 것 같다.🤯 native code에 대해서 한 번 찾아보는 시간을 갖어야할 것 같다.

> > 참고) 단순 indexOf와 for문의 비교는 찾을 수 있었다. 미세하게나마 for문의 연산 속도가 빨랐다. 이 부분에 대한 이유는 내부적으로 반복 전에 객체로 캐스팅하는 작업을 하기 때문에 느리다고 한다. [Link](https://medium.com/@mrashes2/indexof-vs-for-loop-6a9f7bd5c646)
